%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Exercises template
%
% Author: Francisco Luque Sánchez (@pacron on github)
%
% Feel free to download, use and share this template :)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[12pt]{article}       % class document and font size
\usepackage[utf8]{inputenc}         % allowance of accents (spanish writing)
\usepackage{indentfirst}

% packages for math fonts
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{amsthm}
\newtheorem{theorem}{Teorema}
\renewenvironment{proof}{{\noindent     \bfseries Demostración}\\}

\usepackage{fancyhdr}               % fancy header: customize your header
\usepackage{geometry}               % set margins in easy way

\geometry{a4paper, margin=1in}      % set 1 inch in every margin

% creation of \qed command to add a black square at the end of line
% \renewcommand*{\qed}{\hfill\ensuremath{\blacksquare}}

% header and footer customisation
\pagestyle{fancy}                   % pagestyle
\fancyhf{}                          % erase previous header and footer content
\rhead{Método de Euler en SED}           % right side of header (Usually document or chapter title)
\lhead{Métodos numéricos II}        % left side of header (Usually name)
\chead{}                            % center of header (useless piece of shit :D)
\rfoot{\thepage}                    % right side of footer (page number)
\lfoot{}                            % left side of footer (empty)
\cfoot{}                            % again a center

% Change the tolerance of hyphenation tool
\pretolerance=2000
\tolerance=3000

% Report title
\title{
    Método de Euler en sistemas de ecuaciones diferenciales \\              % Title
    \large Métodos numéricos II              % Subtitle
}

% Own author header
\author{
        María del Mar Ruiz Martín \\
        Antonio R. Moya Martín-Castaño \\
        Francisco Luque Sánchez \\
        Doble Grado de Ingeniería Informática y Matemáticas\\
        Universidad de Granada - UGR\\
        18001 Granada, \underline{Spain}
}
\date{\today}

\begin{document}
\maketitle

\section{Introducción}

En este trabajo explicaremos el método de Euler para resolución numérica de sistemas de ecuaciones diferenciales de primer orden. Este método es una extensión a sistemas de ecuaciones del método de Euler para ecuaciones diferenciales. Aunque no es muy utilizado en la práctica, ya que por sus características no aporta soluciones lo suficientemente buenas, sí que se suele explicar como introducción a los métodos de resolución numérica de ecuaciones diferenciales, dada su simplicidad. Además, es el más básico de lo que se conocen como \textit{métodos explícitos de resolución numérica de EDs}, y el más básico de los métodos de \textit{Runge-Kutta}. Por tanto, suele ser una buena estrategia introducir este método previo a la explicación de los métodos nombrados, ya que los mismos son una generalización de éste.\\

El trabajo irá estructurado de la siguiente forma. Primero, daremos una descripción general del concepto de sistema de ecuaciones diferenciales, ya que será el objeto sobre el que trabajaremos. Concretamente, nos centraremos en sistemas de ecuaciones diferenciales de primer orden. Tras esto, veremos cómo podemos transformar una ecuación diferencial de orden superior en un sistema de ecuaciones diferenciales de primer orden, con el fin de tratar una ecuación diferencial de orden superior con el método de Euler. Posteriormente, explicaremos el método de Euler y su aplicación a los sistemas de ecuaciones diferenciales. Completaremos este apartado con la resolución de dos ejemplos con este método. Por un lado, resolveremos un sistema de ecuaciones diferenciales de primer orden aplicando el método directamente, y por otro, tomaremos una ecuación de orden superior, la convertiremos en un sistema de ecuaciones, y resolveremos dicho sistema con el método nuevamente.\\

\section{Descripción general de un sistema de ecuaciones diferenciales}

Para comenzar, veamos lo que es una ecuación diferencial. Una ecuación diferencial es una igualdad en la que interviene una variable independiente ($t$), una variable dependiente ($x(t)$) y las sucesivas derivadas de la variable dependiente respecto de la independiente. En forma general, podemos escribir dicha ecuación de la siguiente forma:

$$ F(t, x, x', ..., x^{n)}) = 0 $$

Se define el orden de dicha ecuación diferencial como el mayor orden de derivación de la variable dependiente que aparece en dicha ecuación.\\

Una solución de esta ecuación es un conjunto de funciones que satisfacen las condiciones de dicha ecuación.\\

Asociado a esta ecuación diferencial, se define un problema de valores iniciales (PVI) como dicha ecuación diferencial junto con los $n$ valores siguientes. Fijado $t_0$:

$$ x(t_0) = y_0, x'(t_0) = y_1, ..., x_{n-1}(t_0) = y_{n-1} $$

Se dice que un PVI está bien planteado si existe solución, es única y depende de forma continua de los datos del problema.\\

Pasamos ahora a definir el concepto de sistema de ecuaciones diferenciales. Un sistema de ecuaciones diferenciales es un conjunto de ecuaciones diferenciales en las que se ven implicadas una variable independiente, un conjunto de variables dependientes de la misma, y las sucesivas derivadas de dichas variables dependientes respecto de la independiente. En forma general, podemos escribir un sistema de ecuaciones diferenciales como sigue:

$$
\begin{cases}
F_1(t, x_1, x_1', ..., x_1^{n_1)}, ..., x_m, x_m', ..., x_m^{n_m)}) = 0 \\
F_2(t, x_1, x_1', ..., x_1^{n_1)}, ..., x_m, x_m', ..., x_m^{n_m)}) = 0 \\
\vdots \\
F_r(t, x_1, x_1', ..., x_1^{n_1)}, ..., x_m, x_m', ..., x_m^{n_m)}) = 0
\end{cases}
$$

Al igual que para las ecuaciones diferenciales, la solución de un sistema de ecuaciones diferenciales está compuesto por un conjunto de ecuaciones que satisfacen las condiciones impuestas por las ecuaciones del sistema.\\

De nuevo, podemos definir un PVI asociado al sistema de ecuaciones anterior. Dicho PVI viene definido por el sistema de ecuaciones diferenciales más el siguiente conjunto de valores:
$$ x_1(t_0) = y_{10}, ..., x_1^{n_1-1)}(t_0) = y_{1n_1-1}, ..., x_m(t_0) = y_{m0}, ..., x_1^{n_m-1)}(t_0) = y_{mn_m-1} $$

Se dice que un sistema de ecuaciones diferenciales está bien planteado si cumple las propiedades definidas previamente:

\begin{itemize}
\item $\exists$ solución
\item Es única
\item Depende de forma continua de las propiedades del problema
\end{itemize}

Durante el trabajo, dado que el método de Euler se aplica a ecuaciones y sistemas de primer orden, trabajaremos con este tipo de sistemas. Podemos escribir este tipo de sistemas de la siguiente manera:

$$
\begin{cases}
F_1(t, x_1, ..., x_m) = \frac{d x_1}{d t} \\
F_2(t, x_1, ..., x_m) = \frac{d x_2}{d t} \\
\vdots \\
F_m(t, x_1, ..., x_m) = \frac{d x_m}{d t}
\end{cases}
$$

Y asociado a este sistema de ecuaciones, el PVI definido por el sistema anterior y el conjunto de valores:

$$ x_1(t_0) = y_1, x_2(t_0) = y_2, ..., x_m(t_0) = y_m $$

\section{Ecuaciones diferenciales de orden superior y reescritura como sistemas}

En la sección anterior definimos el concepto de ecuación diferencial de orden superior y el de sistema de ecuaciones diferenciales. Veamos ahora cómo reescribir una ecuación diferencial de orden $n$ en un sistema de ecuaciones diferenciales en el que se tienen $n$ ecuaciones diferenciales de primer orden. Este paso es necesario para poder aplicar posteriormente el método de Euler, ya que este método sólo puede ser aplicado a ecuaciones diferenciales de primer orden. Veamos entonces esta forma de reescribir las ecuaciones diferenciales de orden superior. Sea la ecuación diferencial de orden $n$: $ F(t, x, x', ..., x^{n)}) = 0 $. Podemos escribir el siguiente sistema de ecuaciones diferenciales, cuya solución es equivalente a la de la ecuación anterior. Tomamos los siguientes cambios de variable:

$$y_0 = x, y_1 = x', y_2 = x'', \dots, y_{n-1} = x^{n-1)}$$

Entonces, la solución de $y_0$ para el siguiente sistema de ecuaciones siguiente es la solución de la ecuación diferencial inicial:

$$
\begin{cases}
y_0' = x' = y_1\\
y_1' = x'' = y_2\\
\vdots\\
y_{n-2}' = x^{n-1)} = y_{n-1}\\
y_{n-1}' = x^{n)} = F(t, y_1, y_2, \dots, y_{n-1})
\end{cases}
$$

Una vez convertida la ecuación en el sistema anterior, estamos en condiciones de aplicar el método de Euler para resolverlo.

\section{Método de Euler para sistemas de ecuaciones diferenciales}

Recordemos primero el método de Euler para un problema de valores iniciales (PVI) bien planteado. Si tomamos puntos en el intervalo [a,b] y un N natural, de forma que $h=(a+b)/N$. Para cada i=0,...,N, los puntos serían
$$ 
t_i=a+ih;
$$
y dado el PVI:
$$
\begin{cases}
y'(t)=f(t,y(t)) \\ 
y(t_0)=y_0
\end{cases}
$$

Podemos tratar de aproximar la solución mediante el método de Euler. Mediante el desarrollo de Taylor centrado en $t_i$ evaluando en el punto $t_{i+1}$:
$$
y(t_{i+1})=y(t_i) + y'(t_i)(t_{i+1}-t_i) + y''(\xi_i)(t_{i+1}-t_i)^2/2
$$

para algún $\xi_i$ entre $(t_i, ti_{i+1})$.

Si observamos, lo escrito anteriormente es equivalente a:
$$
y(t_{i+1})=y(t_i) + f(t_i,y(t_i))h + y''(\xi_i)h^2/2,
$$ 

y lo que es lo mismo:

$$
y(t_{i+1})=y(t_i) + f(t_i,y(t_i))h + O(h^2).
$$

De este modo el método de Euler construye un $w_i \approx y(t_i)$ para cada $i=1,...,N$
$$
\begin{cases}
w_0=y_0\\
w_{i+1}=w_i + hf(t_i,w_i)
\end{cases}
$$

Para el caso de sistemas de ecuaciones diferenciales de primer orden:
$$
\begin{cases}
x_1'=F_1(t,x_1(t),...,x_n(t)) \\
\vdots\\
x_n'=F_n(t,x_1(t),...,x_n(t))
\end{cases}
$$

tenemos que para cada $j=1,...,n$, podemos hacer una aproximación de $w_{i,j} \approx x_j(t_i)$ de forma que:
$$
\begin{cases}
w_{0,j}=x_{j,0} \\
w_{i+1,j}=w_{i,j}+ hF_j(t_i,w_{i,j})
\end{cases}
$$

De este modo, escribiendo el sistema con la siguiente notación matricial:
$$
X'(t)=F(t,X(t))
$$
donde X(t) es de la forma:

\begin{equation*}
X(t)=\begin{bmatrix}
	x_1(t) \\
	\vdots \\
	x_n(t)
	\end{bmatrix}
\end{equation*}
y F(t,X(t)):
\begin{equation*}
F(t,X(t))=\begin{bmatrix}
F_1(t,x_1(t),...,x_n(t)) \\
\vdots \\
F_n(t,x_n(t),...,x_n(t))
\end{bmatrix}
\end{equation*}

podemos expresar una aproximación $W_i \approx X(t_i)$ de a siguiente manera:
$$
\begin{cases}
W_0=X(t_0)\\
W_{i+1}=W_i + hF(t_i,W_i)
\end{cases}
$$
donde $W_i$ es de la forma:

\begin{equation*}
W_i=\begin{bmatrix}
w_1(t_i) \\
\vdots \\
w_n(t_i)
\end{bmatrix}
\end{equation*}

\section{Estudio del error y análisis de la convergencia del método}

Antes de comenzar con el estudio del error, comenzaremos definiendo los tipos de errores que se pueden encontrar cuando se utilizan métodos numéricos para resolución de ecuaciones diferenciales:

\begin{description}
\item[Error local] Se define como el error que se produce en un sólo paso del algoritmo, si se supone que el valor obtenido en la aproximación anterior es exacto.
\item[Error global] Se define como el error total cometido con la aproximación tras las $n$ iteraciones del método. Como veremos más adelante, no es la suma de los errores locales cometidos en todas las iteraciones, sino que se ve incrementado.
\item[Error de truncatura] Es el error que se produce por la precisión finita de las máquinas que se utilizan para computar los cálculos.
\end{description}

Estudiemos ahora los errores definidos en el método de Euler aplicado a sistemas de ecuaciones diferenciales.

\subsection{Error local}

Como ya hemos dicho antes, se define el error local como el que se produce en un paso del algoritmo, suponiendo que el valor del que partimos $(t_i, X_i)$ es un valor real del sistema de ecuaciones. Entonces, tenemos que el error local cometido en la iteración $i+1$ lo podemos expresar como $E_{i+1} = ||X(t_{i+1}) - [X(t_{i}) + h*F(t_i, X_i)] ||$. Veamos cómo 

\begin{theorem} Error local del método de Euler.\\
El error local para el método de Euler es $O(h^2)$, donde $h$ es el tamaño del paso que hemos elegido para aplicar el método ($h=(b-a)/N$).
\end{theorem}

\begin{proof}
Veamos la demostración de dicho resultado. Tomamos el PVI asociado al sistema de ecuaciones diferenciales:
$$ X' = F(t, X),\, X(t_0) = X_0 $$
Supongamos que tenemos la el valor exacto para un determinado $t_i$, es decir, tenemos $(t_i, X_i)$ exacto. Entonces, el error local para la siguiente iteración es $|| E_{i+1} || = ||X(t_{i+1}) - [X(t_{i}) + h*F(t_i, X_i)] ||$. Tomando cada una de las componentes por separado, y expresando $x_j(t_{i+1}), j = 1, ..., n$ usando su polinomio de Taylor centrado en $t_i$ tenemos:
$$ x_j(t_{i+1}) = x_j(t_i) + h*x'_j(t_i) + \frac{h^2}{2}*x''_j(t_i) + \frac{h^3}{3!}*x'''_j(t_i) + ... $$
Donde $h = t_{i+1} - t_i$. Con el método de Euler, la aproximación que obtenemos para $x_j(t_i) = \omega_{i+1, j}$ es:
$$ \omega_{i+1, j} = x_j(t_i) + h*f_j(t_i, x_1, ..., x_n) = x_j(t_i) + h*x'_j(t_i) $$
Restando ambas expresiones, tenemos que para cada $x_j$, el error cometido en un paso del método es:
$$ e_{i+1, j} = | x_j(t_{i+1}) - \omega_{i+1, j} | = \frac{h^2}{2}*x''_j(\xi_{i+1, j}),\, \xi_{i+1, j} \in [t_i, t_{i+1}] $$
Tenemos entonces que el vector de los errores lo podemos expresar como sigue:

\begin{equation*}
E_{i+1}=\begin{bmatrix}
e_{i+1, 1} \\
\vdots \\
e_{i+1, n}
\end{bmatrix}=\begin{bmatrix}
\frac{h^2}{2}*x''_1(\xi_{i+1, 1}) \\
\vdots \\
\frac{h^2}{2}*x''_n(\xi_{i+1, n})
\end{bmatrix}
\end{equation*}

Tomando ahora la norma euclídea del vector de los errores, tenemos que el error es $O(h^2)$

\qed
\end{proof}

\section{Ejemplos y ejercicios resueltos}

\subsection{Método de Euler para sistemas de ecuaciones}

\subsection{Método de Euler para ecuaciones de orden superior}
 
En primer lugar vamos a realizar el paso de una ecuación diferencial de orden superior a un sistema, sobre el cual posteriormente podremos aplicar el método de Euler para sistemas. Para ejemplificar el proceso vamos a usar el siguiente problema de valores iniciales: 

$$
x''' = 2x'' - 2x'     % x(t) = e^tcos(t)
$$
$$
x(0)=1, x'(0)=1, x''(0)=0
$$

Realizamos el cambio de variable indicado en la sección \textit{Ecuaciones diferenciales de orden superior y reescritura como sistemas}:

$$
\begin{cases}
y_0' = x' = y_1\\
y_1' = x'' = y_2\\
y_2' = x''' = 2y_2 - 2y_1
\end{cases}
$$

A continuación pasaremos a resolver el sistema con el método de Euler. Para ello consideraremos el intervalo [0,1] y una longitud de paso h = 0.1.

\section{Artículo}

En esta sección realizaremos un resumen del artículo ``Numerical solution of differential equations using multiquadric radial basis function networks"(Nam Mai-Duy, Thanh Tran-Cong; 2001). En este artículo se introducirá una técnica novedosa para la resolución de ecuaciones diferenciales ordinarias, a partir de ahora ODEs, y ecuaciones diferenciales parciales, PDEs. Previo al resumen veamos una breve descripción de red neuronal:\\

En el contexto de la informática una red neuronal es un conjunto de unidades menores llamadas neuronas interconectadas entre sí. Cada neurona, a partir de un conjunto de entradas, es capaz de proporcionar una salida en la que aparentemente se aplica inteligencia. Para generar dicha salida se hace uso de funciones con carácter probabilísticos cuyos pesos habrá que ajustar en la fase de entrenamiento. Esta fase de entrenamiento consistene en proporcionar un conjunto de entradas con sus correspondientes salidas, de forma que la red neuronal se ajusta según estos datos proporcionados, es decir, modifica dichas funciones a través del conocimiento proporcionado y de esta forma ``aprende" a dar la respuesta correcta para el problema en cuestión con una probabilidad de acierto muy elevada.\\

Los métodos clásicos para la obtención de aproximaciones de la solución de ecuaciones diferenciales suponen un proceso costoso al tener que seleccionar un dominio adecuado con un número finito de elementos para proceder con el mismo. En este artículo, como ya se ha comentado, se presenta un método novedoso para la resolución de ecuaciones diferenciales lineales haciendo uso de redes neuronales artificiales en el que no habrá problema para seleccionar el dominio. \\

En el método presentado en el artículo se hace uso de redes de base radial, que son redes neuronales en las que las funciones que determinan la salida serán funciones de base radial, esto es, funciones reales cuya imagen para cada punto viene determinada por la distancia al origen, es decir, diremos que $\phi:\mathbf{R}^n\to \mathbf{R} $  es radial si

$$\exists \Phi:\mathbf{R}\to \mathbf{R}\ \ tq\ \phi(x)=\Phi(\parallel x\parallel)\ \ \forall x\in\mathbf{R}^n$$

Existen diversas funciones de base radial, pero los autores harán uso de las funciones multicuadráticas, que son aquellas que se definen como sigue:

$$\phi(r) = \sqrt{\epsilon^2+r^2}$$

Notaremos a los métodos numéricos que hacen uso de las redes neuronales con funciones de base radial como RBFN, y podremos clasificarlas como directos (DRBFN) e indirectos (IRBFN). Recordemos en primer lugar que los métodos numéricos directos para la aproximación de funciones y sus derivadas son aquellos que aproximan la función y la aproximación de las sucesivas derivadas serán las sucesivas derivadas de dicha aproximación, mientras que los métodos indirectos son aquellos en los que en primer lugar se aproximan las derivadas de mayor orden y posteriormente se consiguen las de orden menor integrando dicha aproximación. Puesto que se hace uso de funciones multicuadráticas, la función aproximación será de la forma:

$$ u(x) = \sum\limits_{i=1}^{m} w^{(i)}g^{(i)}(x) = \sum\limits_{i=1}^{m} w^{(i)}\sqrt{\epsilon^{(i)^2}+x^2}$$

Donde m es el número de neuronas utilizadas en el método y $w^{(i)}$ los pesos asociados a cada neurona obtenidos durante la fase de entrenamiento. Más adelante veremos como determinar $\epsilon^{(i)}$. La norma del error que se cometerá vendrá determinada por:

$$N_e = \sqrt{\frac{\sum\limits_{i=1}^{m}(u_e(x^{(i)})-u(x^{(i)}))^2}{\sum\limits_{i=1}^{m}u_e(x^{(i)})^2}}$$

Para aplicar el método debemos contar con la imagen de una serie de puntos de colocación o nodos $\{u(x^{(i)})=y^{(i)}\}_{i=1}^{n}$ que servirán como entrenamiento para la determinación de la función. Se contará además con otro tipo de puntos, que llamaremos centros, y que se repartirán uniformemente en forma de malla a lo largo de todo el dominio de la función a aproximar. En la figura 1 podemos ver la distribución de los centros y los nodos.\\

\begin{figure}
\centering
\includegraphics[scale=0.45]{centros.png}
\label{figura1}
\caption{Distribución de los centros (círculos) y nodos (*)} 
\end{figure}

A lo largo del artículo los autores darán resultados de la aplicación del método para la resolución de ODEs en dominios regulares y de PDEs en elipses. Entenderemos por dominio regular a aquel que esté formado por el producto cartesiano de intervalos. En dichos dominios nos será relativamente fácil establecer los centros, y aquí es donde reside la única libertad que podemos aplicar en el método. Veamos por qué.\\

A la hora de crear la malla en nuestro dominio podremos hacerla más densa o menos con total libertad, pero estableceremos la siguiente relación con $\epsilon^{(i)}$:

$$\epsilon^{(i)} = \beta d^{(i)}$$

Donde $d^{(i)}$ es la distancia del i-ésimo centro al centro más cercano. Podremos elegir $\beta > 0$ con libertad, aunque dicho parámetro influirá en la función aproximación obtenida. Aunque no hay forma conocida de determinar el valor óptimo de $\beta$ en cada ocasión, experimentalmente los autores han obtenido que los valores óptimos suelen centrarse en el intervalo [7,10].\\

A continuación se pasa al estudio de la aplicación del método para PDEs en dominios elípticos. El problema que surge en este momento es la generación de la malla. La solución es simple: si $\Omega$ es nuestro dominio elíptico, tomaremos $\Omega^*$ dominio regular tal que $\Omega^*\supset \Omega$ , y aplicaremos el método para el dominio $\Omega^*$, aunque los nodos se encontrarán todos dentro de $\Omega$.\\

Tras una serie de ejemplos los autores muestran como el método IRBFN consigue resultados más adecuados que los conseguidos con el método directo, y además, los resultados son mejores para un mayor rango de $\beta$. Los autores dicen no tener una demostración teórica que corrobore este hecho, pero dan la idea intuitiva del porqué de este hecho: al cometer un error determinado con el método directo, al derivar para obtener las sucesivas derivadas intensificamos el error, mientras que en el método indirecto disminuimos el efecto del error cometido.\\%Distribución del error

Durante el artículo también se realizan comparaciones con los métodos clásicos y se concluye que el método directo, en términos de error, es igual de adecuado que los métodos clásicos, mientras que el método indirecto consigue resultados de varios órdenes de magnitud mayor.\\

Finalmente se habla de una futura adecuación del método para dominios irregulares construyendo un recubrimiento finito de dominios regulares y procediendo de igual forma que con el caso del dominio elíptico.\\


\end{document}
